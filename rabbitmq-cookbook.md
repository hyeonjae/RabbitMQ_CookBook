# Chapter 1 : Working with AMQP  
Introduction  
Connecting to the broker  
Producing messages  
Consuming messages  
Using body serialization with JSON  
Using RPC with messaging  
Broadcasting messages  
Working with message routing using direct exchanges  
Working with message routing using topic exchanges  
Guaranteeing message processing  
Distributing messages to many consumers  
Using message properties  
Messaging with transactions  
Handling unroutable messages  

# Chapter 2 : Going beyond the AMQP Standard  
Introduction  
How to let messages expire  
How to let messages expire on specific queues  
How to let queues expire  
Managing rejected or expired messages  
Understanding the alternate exchange extension  
Understanding the validated user-ID extension  
Notifying the consumers of queue failures  
Table of Contents
Understanding the exchange-to-exchange extension  
Embedding message destinations within messages  

# Chapter 3 : Managing RabbitMQ  
Introduction  
Using vhosts  
Configuring users  
Using SSL  
Implementing client-side certificates  
Managing RabbitMQ from a browser  
Configuring RabbitMQ parameters  
Developing Python applications to monitor RabbitMQ  
Developing your own web applications to monitor RabbitMQ  

# Chapter 4 : Mixing Different Technologies  
Introduction  
Using a .NET client  
Binding an app from iPhone to RabbitMQ via MQTT  
Using messaging to update Google Maps on Android  
Publishing messages from Android in the background  
Exchanging RabbitMQ messages with Qpid  
Exchanging RabbitMQ messages with Mosquitto  
Binding a WCF application with .Net clients  

# Chapter 5 : Using RabbitMQ in Web Applications  
Introduction  
Developing web monitoring applications with Spring  
Developing asynchronous web searches with Spring  
Developing web monitoring applications with STOMP  

# Chapter 6 : Developing Scalable Applications  
Introduction  
Creating a localhost cluster  
Creating a simple cluster  
Adding a RabbitMQ cluster automatically  
Introducing a load balancer to consumers  
Creating clients of the cluster  

# Chapter 7 : Developing High-availability Applications  
Introduction  
Mirroring queues  
Synchronizing queues  
Optimizing mirror policies  
Distributing messages between a couple of brokers  
Table of Contents
Creating a geographical cluster replication  
Filtering and forwarding messages  
Combining high-availability technologies together  
Client high availability  

# Chapter 8 : Performance Tuning for RabbitMQ  
Introduction  
Multithreading and queues  
System tuning  
Improving bandwidth  
Using different distribution tools  

# Chapter 9 : Extending RabbitMQ Functionality  
Introduction  
Enabling and configuring the STOMP plugin  
Managing a RabbitMQ cluster  
Monitoring Shovel status  
Developing new plugins – attaching to a relational database with ODBC  

# Chapter 10: RabbitMQ on AWS  
Introduction  
Using RabbitMQ EC2 instances  
Creating a master image  
Creating a cluster with two EC2 instances  
Using AWS Load Balancing in front of a RabbitMQ cluster  
Configuring EC2 dynamic bind  
Dealing with load spikes and resource optimization in the cloud  

# Chapter 11: AMQP and Cloud Computing – RabbitMQ on PaaS  
Introduction  
RabbitMQ on CloudAMQP  
First application on Cloud Foundry  
Using RabbitMQ on Cloud Foundry  

# Chapter 12 : Managing RabbitMQ Error Conditions  
Introduction  
Monitoring RabbitMQ's behavior  
Using RabbitMQ to troubleshoot itself  
Tracing RabbitMQ's ongoing activity  
Debugging RabbitMQ's messages  
What to do when RabbitMQ fails to restart  
Debugging using Wireshark  
